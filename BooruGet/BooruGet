#!/bin/python3
"""
Frank Hrach
BooruGet
"""


import argparse
import threading
import os
import time

import DownloadManager
from arguments import Arguments
from Gelbooru import GelbooruDownloader


# file names
CONFIG = os.path.join(".config", "BooruGet.config")
FILES = [
    os.path.join(".config", "nsfw_blacklist"), os.path.join(
        ".config", "global_blacklist"),
    os.path.join(".config", "md5_nsfw_blacklist"), os.path.join(
        ".config", "md5_global_blacklist"),
    os.path.join(".config", "md5_nsfw_whitelist"), os.path.join(
        ".config", "md5_global_whitelist"),
    os.path.join(".config", "_nsfw_md5")]

# TODO switch this to load from the config file
OUT_DIR = "src"

# file content arrays
NSFW_BLACKLIST = []
GLOBAL_BLACKLIST = []
MD5_NSFW_BLACKLIST = []
MD5_GLOBAL_BLACKLIST = []
MD5_NSFW_WHITELISTLIST = []
MD5_GLOBAL_WHITELISTLIST = []
NSFW_MD5 = []


def initDirectories():
    """
    Checks to see if the directories used by the program exist, and creates
    them if they do not
    """
    global OUT_DIR
    if not os.path.exists(OUT_DIR):
        os.mkdir(OUT_DIR)

def load_config_file():
    """
    Loads settings from the config file. Creates a blank config file if it
    does not exist already
    """
<<<<<<< HEAD
=======
    global arguments
    global writeLock

    # extract all relevant information from the dictionary
    md5 = result['md5']
    fExtension = result['file_ext']
    height = result['image_height']
    width = result['image_width']
    rating = result['rating']
    tString = result['tag_string']
    tagString = tString.split(" ")

    minWidth = width - width * error
    minHeight = height - height * error

    # maxHeight may not be used...
    maxHeight = tHeight + tHeight * error
    maxHeight = height + height * error

    fail = False
    mark_nsfw = False
    md5_Fail = False
    md5_Global_Fail = False
    md5_Pass = False
    blacklistedTag = []
    globalBlacklistedTag = []

    # calculate the ratio
    ratio = width / float(height)
    tratio = tWidth / float(tHeight)

    maxRatio = tratio + tratio * error
    minRatio = tratio - tratio * error

    # check if the width and height are acceptable
    # if width <= maxWidth and width >= minWidth and height <= maxHeight and
    # height >= minHeight:
    if (ratio >= minRatio and ratio <= maxRatio) or arguments.anysize:
        if (width <= minWidth and height <= minHeight):
        if (width < minWidth or height < minHeight):
            fail = True
            # TODO maybe add verbose message for failed size check
        # if the anysize argument is used, auto-pass this check
        if arguments.anysize:
            fail = False

        # if nfsw is not allowed, check the tag blacklist
        for tag in NSFW_BLACKLIST:
            if tag in tagString:
                if not arguments.nsfw:
                    fail = True
                mark_nsfw = True
                blacklistedTag.append(tag)

        # check if md5 is blacklisted
        if md5 in MD5_NSFW_BLACKLIST and not arguments.nsfw:
            fail = True
            md5_Fail = True

        # check if md5 is blacklisted for nsfw
        if md5 in MD5_GLOBAL_BLACKLIST:
            fail = True
            md5_Global_Fail = True

        # if nsfw is allowed or not allowed check the global blacklist
        for tag in GLOBAL_BLACKLIST:
            if tag in tagString:
                fail = True
                globalBlacklistedTag.append(tag)

        # check if md5 is in the md5 whitelist
        if md5 in MD5_NSFW_WHITELISTLIST:
            md5_Pass = True

        # if nsfw and rating is safe or if md5 was in the whitelist return true
        if(not(rating != "s" and not arguments.nsfw) and not fail) or md5_Pass:
            if arguments.verbose:
                print "Accepted:"
                print "\trating: " + rating
                print "\tmd5: " + md5
                print "\tincluded in md5 nsfw blacklist: " + str(md5_Fail)
                print "\tincluded in md5 global blacklist: " + \
                    str(md5_Global_Fail)
                print "\tincluded in md5 whitelist: " + str(md5_Pass)
                print "\tfile extension: " + fExtension
                print "\tContained blacklisted tag: " + str(blacklistedTag)
                print "\tContained global blacklisted tag: " + \
                    str(globalBlacklistedTag)
                print "\tWidth: " + str(width) + " (minimim: " + \
                    str(minWidth) + ")"
                print "\tHeight: " + str(height) + " (minumum: " + \
                    str(maxHeight) + ")"
                print "\tRatio: " + str(ratio) + "(minimum: " + str(minRatio)\
                    + " maximum: " + str(maxRatio) + ")"
                print "\tnsfw allowed: " + str(arguments.nsfw)
                try:
                    print "\tTag String: " + str(tString)
                except(UnicodeEncodeError):
                    pass

            # if the rating is not s and it is not already marked as nsfw,
            # mark as nsfw
            if (not rating == "s") and (not str(md5) in NSFW_MD5):
                if arguments.verbose:
                    print "\t\tmarking as nsfw"
                NSFW_MD5.append(str(md5))
                while writeLock:
                    time.sleep(500)
                writeLock = True
                f = open("._nsfw_md5", "a+")
                f.write(md5 + '\n')
                f.close()
                writeLock = False
                if arguments.verbose:
                    print "\t\tdone"
            # otherwise go through each tag. If the tag is recognized as nsfw
            # mark the image as nsfw
            elif mark_nsfw and (not str(md5) in NSFW_MD5):
                if arguments.verbose:
                    print "\t\tmarking as nsfw"
                NSFW_MD5.append(str(md5))
                while writeLock:
                    time.sleep(500)
                writeLock = True
                f = open("._nsfw_md5", "a+")
                f.write(md5 + '\n')
                f.close()
                writeLock = False
                if arguments.verbose:
                    print "\t\tdone"
            return True
        else:
            if arguments.verbose:
                print "Skipped:"
                print "\trating: " + rating
                print "\tmd5: " + md5
                print "\tincluded in md5 blacklist: " + str(md5_Fail)
                print "\tincluded in md5 global blacklist: " + \
                    str(md5_Global_Fail)
                print "\tincluded in md5 whitelist: " + str(md5_Pass)
                print "\tincluded in md5 whitelist: " + str(md5_Pass)
                print "\tfile extension: " + fExtension
                print "\tContained blacklisted tag: " + str(blacklistedTag)
                print "\tContained global blacklisted tag: " + \
                    str(globalBlacklistedTag)
                print "\tWidth: " + str(width) + " (minimim: " + \
                    str(minWidth) + ")"
                print "\tHeight: " + str(height) + " (minumum: " + \
                    str(maxHeight) + ")"
                print "\tRatio: " + str(ratio) + " (target: " + str(tratio) + \
                    " minimum: " + str(minRatio) + " maximum: " + \
                    str(maxRatio) + ")"
                print "\tnsfw allowed: " + str(arguments.nsfw)
                try:
                    print "\tTag String: " + str(tString)
                except(UnicodeEncodeError):
                    pass
                return False
    else:
        if arguments.verbose:
            print "failed size test"
            print "Skipped:"
            print "\trating: " + rating
            print "\tmd5: " + md5
            print "\tincluded in md5 blacklist: " + str(md5_Fail)
            print "\tincluded in md5 global blacklist: " + str(md5_Global_Fail)
            print "\tincluded in md5 whitelist: " + str(md5_Pass)
            print "\tincluded in md5 whitelist: " + str(md5_Pass)
            print "\tfile extension: " + fExtension
            print "\tContained blacklisted tag: " + str(blacklistedTag)
            print "\tContained global blacklisted tag: " + \
                str(globalBlacklistedTag)
            print "\tWidth: " + str(width) + " (minimim: " + str(minWidth) + \
                ")"
            print "\tHeight: " + str(height) + " (minumum: " + \
                str(maxHeight) + ")"
            print "\tRatio: " + str(ratio) + " (target: " + str(tratio) + \
                " minimum: " + str(minRatio) + \
                " maximum: " + str(maxRatio) + ")"
            print "\tnsfw allowed: " + str(arguments.nsfw)
            print "\tTag String: " + str(tString)

    return False


def downloadImage(url, location):
    global numthreads
    call(["wget", "-q", "-N", "-P" + location, url])
    numthreads -= 1


def updateMD5BlackAndWhiteLists():
    # list of al the blacklist/whitelist files. Each one corrisponds with
    # it's data structure equivalent
    structs = [
        MD5_NSFW_BLACKLIST, MD5_GLOBAL_BLACKLIST, MD5_NSFW_WHITELISTLIST,
        MD5_GLOBAL_WHITELISTLIST]

    for i in range(len(FILES)):

        # try and load the contents of the file
        try:
            f = open(FILES[i])
            for line in f:
                structs[i].append(str(line))
            f.close()
        except Exception, e:
            print "Error opening " + FILES[i]
            print e
            sys.exit()


def loadBlackAndWhiteLists():
    global arguments
    global NSFW_BLACKLIST
    global GLOBAL_BLACKLIST
    global MD5_NSFW_BLACKLIST
    global MD5_GLOBAL_BLACKLIST
    global MD5_NSFW_WHITELISTLIST
    global MD5_GLOBAL_WHITELISTLIST
    global NSFW_MD5

    # list of al the blacklist/whitelist files. Each one corrisponds with
    # it's data structure equivalent
    structs = [
        NSFW_BLACKLIST, GLOBAL_BLACKLIST, MD5_NSFW_BLACKLIST,
        MD5_GLOBAL_BLACKLIST, MD5_NSFW_WHITELISTLIST, MD5_GLOBAL_WHITELISTLIST,
        NSFW_MD5]

    for i in range(len(FILES)):

        # if the file does not exist, create it
        if not os.path.exists(FILES[i]):
            f = open(FILES[i], "w")
            f.write('')
            f.close()

        # then try and load the contents of the file
        try:
            f = open(FILES[i])
            for line in f:
                structs[i].append(str(line.strip()))
            f.close()
        except Exception, e:
            print "Error opening " + FILES[i]
            print e
            sys.exit()


def loadConfigfile():
    global arguments
>>>>>>> 32e8bcd3c1aea968895561110bf9defed5510caa
    global CONFIG

    if not os.path.exists(".config"):
        os.mkdir(".config")

    valid_settings = {"username": None, "apikey": None}

    # if the config file does not exist, create it
    if not os.path.exists(CONFIG):
        f = open(CONFIG, "w")
        f.write('username \n')
        f.write('apikey ')
        f.close()

    f = open(CONFIG, "r")
    try:
        for line in f:
            current = line.strip().split(" ")
            valid_settings[current[0]] = current[1]
    except:
        #this is most likely not a problem
        pass
    return valid_settings


def handleArguments(arguments):
    """
    Handles the command line arguments for the program

    arguments -> a dictionary containg any arguments from the config file

    returns -> the dictionary provided updated with the command arguments
    """

    parser = argparse.ArgumentParser()
    parser.add_argument(
        "-a", "--anysize", help="Allow any sized image. " +
        "Default is to only allow images equal to or larger than the " +
        "specified screen size", action="store_true")
    parser.add_argument(
        "-u", "--username", default=arguments["username"],
        help="The username you use to log into danbooru this overrides what " +
        "is found in the config file if specified")
    parser.add_argument(
        "-k", "--apikey", default=arguments["apikey"],
        help="Your api key can be found on your user page. This overrides " +
        "what is found in the config file if specified")
    parser.add_argument(
        "-w", "--width", help="the width of your screen in pixels", default=-1,
        type=int)
    parser.add_argument(
        "-t", "--height", help="the height of your screen in pixels",
        default=-1, type=int)
    parser.add_argument(
        "-e", "--error", help="the percentage error allowed for the image." +
        "Default is 5 percent", default=0.05, type=float)
    parser.add_argument(
        "-v", "--verbose", help="prints debug output", action="store_true")
    parser.add_argument(
        "--nsfw", help="Allow nsfw results, default is disallow",
        action="store_true")
    parser.add_argument(
        "-l", "--localonly", help="Do not download, use local files only",
        action="store_true")
    parser.add_argument(
        "--nodan", help="Do not download from danbooru", action="store_true")
    parser.add_argument(
        "--nogel", help="Do not download from gelbooru",
        action="store_true")
    parser.add_argument(
        "search", help="the string to search for. It is the exact same " +
        "string that would be entered into the site")

    return dict(list(arguments.items()) +
        list(vars(parser.parse_args()).items()))


def main():
    """
    The entry point for the program
    """
    global OUT_DIR
    try:
        arguments = load_config_file()
        arguments = handleArguments(arguments)

        args = Arguments(arguments['anysize'], arguments['height'], \
               arguments['width'], arguments['error'], arguments['verbose'], \
               arguments['nsfw'], arguments['search'], arguments['username'], \
               arguments['apikey'])


        if args.verbose:
            print("Arguments:")
            print('\n' + str(arguments))

        threads = []
        event = threading.Event()
        dl_manager = DownloadManager.DownloadManager(event, OUT_DIR)

        if not arguments['localonly']:
            threads.append(dl_manager)

            if not arguments['nogel']:
                gel = GelbooruDownloader(args, dl_manager)
                threads.append(gel)
            if not arguments['nodan']:
                #TODO write danbooru code
                pass

            # Start all threads
            print("Starting downloads")
            for thread in threads:
                thread.start()

            # remove the download thread
            threads.pop(0)

            # Wait for all threads to finish
            for thread in threads:
                print("join")
                thread.join()

            print("Main thread done")

    except (KeyboardInterrupt, SystemExit):
        dl_manager.should_run = False
        raise

# Entry Point
main()
